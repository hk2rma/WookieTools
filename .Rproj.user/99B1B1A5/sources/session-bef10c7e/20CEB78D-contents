
# Name
# Version 0.1
# All input objects are Seurat Objects unless mentioned otherwise

suppressMessages(library(Matrix))
suppressMessages(library(dplyr))
suppressMessages(library(tidyr))
suppressMessages(library(tidyverse))
suppressMessages(library(scds))
suppressMessages(library(SingleCellExperiment))
suppressMessages(library(Seurat))
suppressMessages(library(ggplot2))
suppressMessages(library(plyr))
suppressMessages(library(cowplot))
suppressMessages(library(patchwork))
suppressMessages(library(singleCellTK))


# Seurat Object Quality Control function
#---------------------------------------
# Run Iteratively
# change 'mt' to 'MT' depending on Mouse/Human dataset
# Potential error with feature name, change as needed
qc <- function(matrix, nf_min = nf_min,nf_max = nf_max, nc = nc, pmt = pmt, group = 'orig.ident', colors = NULL) {
  matrix[['percent.ribo']] <- PercentageFeatureSet(matrix, pattern = "^Rp[sl]")
  matrix[["percent.mt"]] <- PercentageFeatureSet(matrix, pattern = "^mt-")
  matrix <- subset(matrix, subset = nf_min < nFeature_RNA & nFeature_RNA < nf_max & nCount_RNA < nc & percent.mt < pmt)
  options(repr.plot.width = 16, repr.plot.height = 30) 
  vl_plot <- VlnPlot(matrix, features = c("nFeature_RNA", "nCount_RNA", "percent.mt", "percent.ribo"),
                     ncol = 4)
  options(repr.plot.width = 16, repr.plot.height = 35)
  g <- FeatureScatter(matrix,
                      feature1 = "nCount_RNA",
                      feature2 = "nFeature_RNA",
                      group.by = group, shape = 1) + ggtitle('nCount_vs_nFeature') +
    geom_point(shape = 1, alpha = 0.3)
  
  plot2 <- FeatureScatter(matrix,
                          feature1 = "percent.mt",
                          feature2 = "nFeature_RNA") + ggtitle('percent.mt_vs_nFeature') +
    geom_point(shape = 1, alpha = 0.3) + facet_wrap(~colors)
  
  plot3 <- FeatureScatter(matrix,
                          feature1 = "percent.ribo",
                          feature2 = "nFeature_RNA") + ggtitle('percent.ribo_vs_nFeature') +
    geom_point(shape = 1, alpha = 0.3) + facet_wrap(~colors)
  
  plot4 <- FeatureScatter(matrix,
                          feature1 = "percent.mt",
                          feature2 = "percent.ribo") + ggtitle('percent.mt_vs_percent.ribo') +
    geom_point(shape = 1, alpha = 0.3) + facet_wrap(~colors)
  
  # Combine all plots into a single plot
  c_plot<- plot_grid(g, plot2, plot3, plot4, ncol = 2,label_size = 10)
  combined_plot<-  plot_grid(vl_plot,c_plot,ncol = 1,nrow = 2,rel_widths = c(2,1))
  # Display the combined plot
  print(combined_plot)
  
  return(matrix)
}

# Doublet finder using scds
# Not recomended, use scrublet (scrubdub) instead
scds_doublets <- function(matrix){
  print('Not recommended!, use scrubdub (Scrublet) instead')
  suppressMessages(a_matrix <- NormalizeData(matrix))
  suppressMessages(a_matrix <- FindVariableFeatures(a_matrix, selection.method = "vst", nfeatures = 3000))
  suppressMessages(a_matrix <- ScaleData(a_matrix))
  suppressMessages(a_matrix <- RunPCA(a_matrix))
  suppressMessages(a_matrix <- RunUMAP(a_matrix, dims = 1:10))  
  sce <- as.SingleCellExperiment(a_matrix)
  sce = bcds(sce, retRes = TRUE, estNdbl=TRUE)
  ## Annotate doublet using co-expression based doublet scoring:
  try({
    sce = cxds(sce, retRes = TRUE, estNdbl=TRUE)
  })
  ### If cxds worked, run hybrid, otherwise use bcds annotations
  if ("cxds_score" %in% colnames(colData(sce))) {
    ## Combine both annotations into a hybrid annotation
    sce = cxds_bcds_hybrid(sce, estNdbl=TRUE)
    Doublets <- as.data.frame(cbind(rownames(colData(sce)), colData(sce)$hybrid_score, colData(sce)$hybrid_call))
  } else {
    print("this pool failed cxds so results are just the bcds calls")
    Doublets <- as.data.frame(cbind(rownames(colData(sce)), colData(sce)$bcds_score, colData(sce)$bcds_call))
  }
  ## Doublet scores are now available via colData:
  colnames(Doublets) <- c("Barcode","scds_score","scds_DropletType")
  Doublets$scds_DropletType <- gsub("FALSE","singlet",Doublets$scds_DropletType)
  Doublets$scds_DropletType <- gsub("TRUE","doublet",Doublets$scds_DropletType)
  a_matrix@meta.data$Doublet_score = as.numeric(Doublets$scds_score)
  matrix@meta.data$Doublet_score = as.numeric(Doublets$scds_score)
  a_matrix@meta.data$Doublet_score
  matrix@meta.data$Doublet_type = Doublets$scds_DropletType
  DimPlot(a_matrix, reduction = 'umap')
  hist(matrix@meta.data$Doublet_score)
  return(matrix)
}


# Doublet finder using Scrublet
scrub_dub <- function(seu_obj){
  suppressMessages(seu_obj <- NormalizeData(seu_obj))
  suppressMessages(seu_obj <- FindVariableFeatures(seu_obj, selection.method = "vst", nfeatures = 3000))
  suppressMessages(seu_obj <- ScaleData(seu_obj))
  suppressMessages(seu_obj <- RunPCA(seu_obj))
  sce_obj <- as.SingleCellExperiment(seu_obj)
  sce_scrub <- runScrublet(sce_obj)
  seu_obj_scrubbed <- as.Seurat(sce_scrub)
  scrub_scores <- seu_obj_scrubbed@meta.data$scrublet_score
  scrub_type <- seu_obj_scrubbed@meta.data$scrublet_call
  seu_obj@meta.data$scrublet_score = scrub_scores
  seu_obj@meta.data$scrublet_call = scrub_type
  hist(scrub_scores)
  return(seu_obj)
}

# Function to sum the counts of two matrices containing the same cells
# Input: Count Matrices | Output: Seurat Object
sum_matrices <- function(matrix1, matrix2, sample = 'sample', min_cells = 3, min_features = 200) {
  
  # Check if row names are identical
  if (!identical(rownames(matrix1), rownames(matrix2))) {
    stop('Error: Row names are not identical.')
  }
  # Check if Column names are identical
  if (!identical(rownames(matrix1), rownames(matrix2))) {
    print(paste0('Warning: Column names are not identical.'))
  }
  # Identify columns not common to both matrices
  extra_cols_matrix1 <- setdiff(colnames(matrix1), colnames(matrix2))
  extra_cols_matrix2 <- setdiff(colnames(matrix2), colnames(matrix1))
  
  common_rows <- intersect(rownames(matrix1), rownames(matrix2))
  common_cols <- intersect(colnames(matrix1), colnames(matrix2))
  
  # Subset matrices to common rows and columns
  matrix1_common <- matrix1[which(rownames(matrix1) %in% common_rows), which(colnames(matrix1) %in% common_cols)]
  matrix2_common <- matrix2[which(rownames(matrix2) %in% common_rows), which(colnames(matrix2) %in% common_cols)]
  
  # Sum the matrices
  result_matrix <- matrix1_common + matrix2_common
  
  # Concatenate extra columns to the right of the result matrix
  if (length(extra_cols_matrix1) > 0) {
    matrix1_uncommon <- matrix1[common_rows,extra_cols_matrix1]
    result_matrix <- cbind(result_matrix, matrix1_uncommon)
  }
  
  if (length(extra_cols_matrix2) > 0) {
    matrix2_uncommon <- matrix2[common_rows,extra_cols_matrix2]
    result_matrix <- cbind(result_matrix, matrix2_uncommon)
  }
  
  original_col_order <- c(colnames(matrix1), extra_cols_matrix2)
  result_matrix <- result_matrix[, original_col_order]
  
  # Create Seurat object
  seu_obj <- CreateSeuratObject(result_matrix, min.cells = min_cells, min.features = min_features, project = sample)
  
  return(seu_obj)
}


# Function to run and plot multiple UMAP's for different numbers of a feature(Highly variable genes or Most Abundant genes)
# Features must be obtained and given as input
plot_multi_feat_umap <- function(object = seu_obj, features = features, min.dist = 0.1, 
                                 max_features = 3000,ftype='HVG',
                                 step = 500,out_name = 'combined_umap') {
  plot_list <- list()
  
  for (feature_length in seq(500, max_features, step)) {
    current_features <- features[1:feature_length]
    cat(paste0('Calculating UMAP at ',ftype,':',feature_length))
    current_umap <- RunUMAP(object, features = current_features, min.dist = min.dist)
    current_plot <- DimPlot(current_umap, reduction = 'umap') + ggtitle(paste('UMAP ',ftype, feature_length))
    plot_list[[length(plot_list) + 1]] <- current_plot
    cat(paste0('UMAP done for ',ftype,':',feature_length))
  }
  
  # Combine plots into a grid
  combined_plot <- plot_grid(plotlist = plot_list)
  
  # Assign the combined plot to a variable in the global environment
  assign(out_name, combined_plot, envir = globalenv())
  
  # Return the combined plot
  return(combined_plot)
}


# Function plots multiple UMAP's at diffrent min.dist values
plot_multi_min_dist_umap <- function(object = seu_obj, features = features, 
                                      out_name = 'min_dist_umaps') {
  plot_list <- list()
  
  for (min_dist in seq(0.1, 0.5, 0.1)) {
    current_md <- min_dist
    cat(paste0('Calculating UMAP at min.dist:',current_md))
    current_umap <- RunUMAP(object, features = features, min.dist = current_md)
    current_plot <- DimPlot(current_umap, reduction = 'umap') + ggtitle(paste('UMAP: min.dist:', current_md))
    plot_list[[length(plot_list) + 1]] <- current_plot
    cat(paste0('UMAP done at min.dist:',current_md))
  }
  
  # Combine plots into a grid
  combined_plot <- plot_grid(plotlist = plot_list)
  
  # Assign the combined plot to a variable in the global environment
  assign(out_name, combined_plot, envir = globalenv())
  
  # Return the combined plot
  return(combined_plot)
}


# Function to plot multiple features with colour map
# Input seurat object and a list of features to plot
multi_feature_plots <- function(seuratObject, featureList, ncol = 3, pt.size = 0.8) {
  plotList <- lapply(featureList, function(feature) {
    FeaturePlot(object = seuratObject, features = feature, pt.size = pt.size, reduction = "umap") +
      theme(aspect.ratio = 1) +
      scale_color_gradientn(colours = c("#DCDCDC", "yellow", "orange", "red", "#8b0000"))
  })
  
  plotGrid <- plot_grid(plotlist = plotList, ncol = ncol, rel_widths = rep(1, length(featureList)))
  
  return(plotGrid)
}
