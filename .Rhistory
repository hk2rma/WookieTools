suppressMessages(library(singleCellTK))
knitr::opts_chunk$set(echo = TRUE)
source("jedi_tools.R")
library(sctransform)
sa1_1 <- Read10X('slx_22393/SLX-22393_SITTA1')
sa1_2 <- Read10X('slx_22607/SLX-22607_SITTA1')
sf12_1 <- Read10X('slx_22393/SLX-22393_SITTF12')
sf12_2 <- Read10X('slx_22607/SLX-22607_SITTF12')
sg12_1 <- Read10X('slx_22393/SLX-22393_SITTG12')
sg12_2 <- Read10X('slx_22607/SLX-22607_SITTG12')
sh12_1 <- Read10X('slx_22393/SLX-22393_SITTH12')
sh12_2 <- Read10X('slx_22607/SLX-22607_SITTH12')
sa1 <- sum_matrices(sa1_1,sa1_2,sample = 'SITTA1')
sf12 <- sum_matrices(sf12_1,sf12_2,sample = 'SITTF12')
sg12 <- sum_matrices(sg12_1,sg12_2,sample = 'SITTG12')
sh12 <- sum_matrices(sh12_1,sh12_2,sample = 'SITTH12')
sa1_dqc <- as.Seurat(runDropletQC(as.SingleCellExperiment(sa1)))
sa1_dqc <- as.Seurat(runEmptyDrops(as.SingleCellExperiment(sa1)))
View(sa1)
sa1 <- scrub_dub(sa1)
knitr::opts_chunk$set(echo = TRUE)
suppressMessages(library(Seurat))
suppressMessages(library(ggplot2))
suppressMessages(library(sctransform))
source('jedi_tools.R')
ps_merged <- readRDS('sct_seu.rds')
sct_seu<- RunPCA(ps_merged, features = VariableFeatures(ps_merged),verbose=FALSE)
var.features <- VariableFeatures(sct_seu)
vf <- var.features[1:4000]
#hvg_3k_seu <- FindNeighbors(sct_seu,k.param = 30,features = vf)
#hvg_3k_seu <- FindClusters(hvg_3k_seu, resolution = 0.8,algorithm = 3)
hvg_3k_seu <- RunUMAP(hvg_3k_seu, features=vf, min.dist=0.3)
sct_seu<- RunPCA(ps_merged, features = VariableFeatures(ps_merged),verbose=FALSE)
var.features <- VariableFeatures(sct_seu)
vf <- var.features[1:4000]
#hvg_3k_seu <- FindNeighbors(sct_seu,k.param = 30,features = vf)
#hvg_3k_seu <- FindClusters(hvg_3k_seu, resolution = 0.8,algorithm = 3)
hvg_3k_seu <- RunUMAP(sct_seu, features=vf, min.dist=0.3)
DimPlot(hvg_3k_seu)
p1<- FeaturePlot(object = hvg_3k_seu, features ='nCount_RNA', pt.size = 0.8, reduction = "umap") +
theme(aspect.ratio = 1) + # yellow: #ffd700; red: #ff0000
scale_color_gradientn(colours = c("#DCDCDC","yellow","orange","red","#8b0000"))
p2<- FeaturePlot(object = hvg_3k_seu, features = 'nFeature_RNA', pt.size = 0.8, reduction = "umap") +
theme(aspect.ratio = 1) + # yellow: #ffd700; red: #ff0000
scale_color_gradientn(colours = c("#DCDCDC","yellow","orange","red","#8b0000"))
p3<- FeaturePlot(object = hvg_3k_seu, features = 'percent.mt', pt.size = 0.8, reduction = "umap") +
theme(aspect.ratio = 1) + # yellow: #ffd700; red: #ff0000
scale_color_gradientn(colours = c("#DCDCDC","yellow","orange","red","#8b0000"))
p4<- FeaturePlot(object = hvg_3k_seu, features = 'percent.ribo', pt.size = 0.8, reduction = "umap") +
theme(aspect.ratio = 1) + # yellow: #ffd700; red: #ff0000
scale_color_gradientn(colours = c("#DCDCDC","yellow","orange","red","#8b0000"))
qc_umap_plots <- plot_grid(p1,p2,p3,p4, ncol = 2,rel_widths = c(1,1))
qc_umap_plots
library(WookieTools)
multi_f_plots(hvg_3k_seu,'Krt14')
View(hvg_3k_seu)
sct_seu<- RunPCA(ps_merged, npcs = 30,verbose=FALSE)
DimPlot(sct_seu,group.by='orig.ident')
var.features <- VariableFeatures(sct_seu)
vf <- var.features[1:3000]
#hvg_3k_seu <- FindNeighbors(sct_seu,k.param = 30,features = vf)
#hvg_3k_seu <- FindClusters(hvg_3k_seu, resolution = 0.8,algorithm = 3)
hvg_3k_seu <- RunUMAP(sct_seu, features=vf, min.dist=0.3)
DimPlot(hvg_3k_seu)
library(WookieTools)
multi_f_plots(hvg_3k_seu,'Krt14')
setwd("C:/Users/ha573/Documents/Hari/WookieTools")
roxygen2::roxygenise()
devtools::document()
roxygen2::roxygenise()
devtools::document()
library(oxygenise)
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
# Version 0.3.5
# All input objects are Seurat Objects unless mentioned otherwise
#' @export
load_libraries <- function() {
required_packages_cran <- c("Matrix", "dplyr", "tidyr", "tidyverse", "SingleCellExperiment", "Seurat", "ggplot2", "plyr", "cowplot", "patchwork")
required_packages_bioc <- c("scds")
installed_packages_cran <- rownames(installed.packages())
installed_packages_bioc <- rownames(utils::installed.packages("BiocManager"))
# Install CRAN packages if not installed
for (package in required_packages_cran) {
if (!(package %in% installed_packages_cran)) {
install.packages(package)
}
}
# Install Bioconductor packages if not installed
if (!"BiocManager" %in% installed_packages_cran) {
install.packages("BiocManager")
}
library(BiocManager)
for (package in required_packages_bioc) {
if (!(package %in% installed_packages_bioc)) {
BiocManager::install(package)
}
}
# Load all required packages
invisible(lapply(c(required_packages_cran, required_packages_bioc), library, character.only = TRUE))
}
load_libraries()
devtools::document()
rm(list = c("load_libraries"))
devtools::document()
library(Seurat)
devtools::document()
library(roxygen2)
roxygenise()
roxygenise()
BiocManager::install('scds',force = TRUE)
roxygenise()
devtools::document()
devtools::document()
roxygen2::roxygenise()
devtools::test()
devtools::test()
use_test('t1')
usethis::use_test('t1')
roxygen2::roxygenise()
devtools::document()
# Load the testthat package
library(testthat)
# Load your custom functions
source("WookieTools.R")
# Load the testthat package
library(testthat)
# Load your custom functions
source("R/WookieTools.R")
# Write test cases using testthat's expect_ functions
test_that("wookieqc filters cells based on specified criteria", {
# Create a mock Seurat object for testing
mock_seurat_obj <- CreateSeuratObject(counts = matrix(rpois(10000, 10), ncol = 100))
# Perform quality control
filtered_obj <- wookieqc(mock_seurat_obj, nf_min = 100, nf_max = 2000, nc_max = 10000, pmt = 10)
# Check if the filtered object has the expected number of cells
expect_equal(nrow(filtered_obj), expected_number_of_cells)
# Add more test cases as needed
})
# Load the testthat package
library(testthat)
# Load your custom functions
source("R/WookieTools.R")
# Write test cases using testthat's expect_ functions
test_that("wookieqc filters cells based on specified criteria", {
# Create a mock Seurat object for testing
mock_seurat_obj <- CreateSeuratObject(counts = matrix(rpois(10000, 10), ncol = 100))
# Perform quality control
filtered_obj <- wookie_qc(mock_seurat_obj, nf_min = 100, nf_max = 2000, nc_max = 10000, pmt = 10)
# Check if the filtered object has the expected number of cells
expect_equal(nrow(filtered_obj), expected_number_of_cells)
# Add more test cases as needed
})
library(Seurat)
# Load your custom functions
source("R/WookieTools.R")
test_mat <- Read10X('test_files/sitta1/filtered_feature_bc_matrix/')
test <- CreateSeuratObject(test_mat,min.cells = 3, min.features = 300, project = 'test')
expected_number_of_cells = 4000
# Write test cases using testthat's expect_ functions
test_that("wookieqc filters cells based on specified criteria", {
# Perform quality control
filtered_obj <- wookie_qc(test, nf_min = 1000, nf_max = 6000, nc_max = 8000, pmt = 5, ptr = 20)
# Check if the filtered object has the expected number of cells
expect_equal(nrow(filtered_obj), expected_number_of_cells)
# Add more test cases as needed
})
View(test)
View(test)
# Load the testthat package
library(testthat)
library(Seurat)
# Load your custom functions
source("R/WookieTools.R")
test_mat <- Read10X('test_files/sitta1/filtered_feature_bc_matrix/')
test <- CreateSeuratObject(test_mat,min.cells = 3, min.features = 300, project = 'test')
expected_number_of_cells = 4310
# Write test cases using testthat's expect_ functions
test_that("wookieqc filters cells based on specified criteria", {
# Perform quality control
filtered_obj <- wookie_qc(test, nf_min = 1000, nf_max = 6000, nc_max = 8000, pmt = 5, ptr = 20)
# Check if the filtered object has the expected number of cells
expect_equal(ncol(filtered_obj), expected_number_of_cells)
# Add more test cases as needed
})
# Load the testthat package
library(testthat)
library(Seurat)
# Load your custom functions
source("R/WookieTools.R")
test_mat <- Read10X('test_files/sitta1/filtered_feature_bc_matrix/')
test <- CreateSeuratObject(test_mat,min.cells = 3, min.features = 300, project = 'test')
expected_number_of_cells = 4310
# Write test cases using testthat's expect_ functions
test_that("wookieqc filters cells based on specified criteria", {
# Perform quality control
filtered_obj <- wookie_qc(test, nf_min = 1000, nf_max = 6000, nc_max = 8000, pmt = 5, ptr = 50)
# Check if the filtered object has the expected number of cells
expect_equal(ncol(filtered_obj), expected_number_of_cells)
# Add more test cases as needed
})
# Load the testthat package
library(testthat)
library(Seurat)
# Load your custom functions
source("R/WookieTools.R")
test_mat <- Read10X('test_files/sitta1/filtered_feature_bc_matrix/')
test <- CreateSeuratObject(test_mat,min.cells = 3, min.features = 300, project = 'test')
expected_number_of_cells = 4310
# Write test cases using testthat's expect_ functions
test_that("wookieqc filters cells based on specified criteria", {
# Perform quality control
filtered_obj <- wookie_qc(test, nf_min = 1000, nf_max = 9000, nc_max = 80000, pmt = 10, ptr = 50)
# Check if the filtered object has the expected number of cells
expect_equal(ncol(filtered_obj), expected_number_of_cells)
# Add more test cases as needed
})
# Load the testthat package
library(testthat)
library(Seurat)
# Load your custom functions
source("R/WookieTools.R")
test_mat <- Read10X('test_files/sitta1/filtered_feature_bc_matrix/')
test <- CreateSeuratObject(test_mat,min.cells = 3, min.features = 300, project = 'test')
expected_number_of_cells = 3750
# Write test cases using testthat's expect_ functions
test_that("wookieqc filters cells based on specified criteria", {
# Perform quality control
filtered_obj <- wookie_qc(test, nf_min = 1000, nf_max = 9000, nc_max = 80000, pmt = 10, ptr = 50)
# Check if the filtered object has the expected number of cells
expect_equal(ncol(filtered_obj), expected_number_of_cells)
# Add more test cases as needed
})
# Write additional test cases for other functions
# Run the tests
test_results <- test_file("test_functions.R")
# Load the testthat package
library(testthat)
library(Seurat)
# Load your custom functions
source("R/WookieTools.R")
test_mat <- Read10X('test_files/sitta1/filtered_feature_bc_matrix/')
test <- CreateSeuratObject(test_mat,min.cells = 3, min.features = 300, project = 'test')
expected_number_of_cells = 3750
# Write test cases using testthat's expect_ functions
test_that("wookieqc filters cells based on specified criteria", {
# Perform quality control
filtered_obj <- wookie_qc(test, nf_min = 1000, nf_max = 9000, nc_max = 80000, pmt = 10, ptr = 50)
# Check if the filtered object has the expected number of cells
expect_equal(ncol(filtered_obj), expected_number_of_cells)
# Add more test cases as needed
})
# Write additional test cases for other functions
# Run the tests
test_results <- test_file("R/test_functions.R")
# Print the test results
print(test_results)
# Define a test for wookie_matrix_sum
test_that("wookie_matrix_sum correctly merges two count matrices",{
# Create mock count matrices for testing
matrix1 <- matrix(1:9, ncol = 3)
matrix2 <- matrix(11:19, ncol = 3)
# Run wookie_matrix_sum on the mock matrices
merged_obj <- wookie_matrix_sum(matrix1, matrix2)
# Check if the merged object has the correct dimensions
expect_equal(nrow(merged_obj), nrow(matrix1))
expect_equal(ncol(merged_obj), ncol(matrix1) + ncol(matrix2))
# Define a test for wookie_matrix_sum
test_that("wookie_matrix_sum correctly merges two count matrices",{
# Create mock count matrices for testing
matrix1 <- matrix(1:9, ncol = 3)
matrix2 <- matrix(11:19, ncol = 3)
# Run wookie_matrix_sum on the mock matrices
merged_obj <- wookie_matrix_sum(matrix1, matrix2)
# Check if the merged object has the correct dimensions
expect_equal(nrow(merged_obj), nrow(matrix1))
expect_equal(ncol(merged_obj), ncol(matrix1) + ncol(matrix2))
})
test_that("wookie_matrix_sum correctly merges two count matrices",{
# Create mock count matrices for testing
matrix1 <- matrix(1:9, ncol = 30)
matrix2 <- matrix(5:19, ncol = 30)
# Run wookie_matrix_sum on the mock matrices
merged_obj <- wookie_matrix_sum(matrix1, matrix2)
# Check if the merged object has the correct dimensions
expect_equal(nrow(merged_obj), nrow(matrix1))
expect_equal(ncol(merged_obj), ncol(matrix1) + ncol(matrix2))
})
# Define a test for wookie_scrub
test_that("wookie_scrub correctly processes a Seurat object", {
scrubbed_obj <- wookie_scrub(test,preprocess = FALSE)
# Check if the scrubbed object contains scrublet_score and scrublet_call columns
expect_true("scrublet_score" %in% colnames(scrubbed_obj@meta.data))
expect_true("scrublet_call" %in% colnames(scrubbed_obj@meta.data))
})
# Load the testthat package
library(testthat)
library(Seurat)
# Load your custom functions
source("R/WookieTools.R")
test_mat <- Read10X('test_files/sitta1/filtered_feature_bc_matrix/')
test <- CreateSeuratObject(test_mat,min.cells = 3, min.features = 300, project = 'test')
expected_number_of_cells = 3750
# Write test cases using testthat's expect_ functions
test_that("wookieqc filters cells based on specified criteria", {
# Perform quality control
filtered_obj <- wookie_qc(test, nf_min = 1000, nf_max = 9000, nc_max = 80000, pmt = 10, ptr = 50)
# Check if the filtered object has the expected number of cells
expect_equal(ncol(filtered_obj), expected_number_of_cells)
# Add more test cases as needed
})
# Define a test for wookie_scrub
test_that("wookie_scrub correctly processes a Seurat object", {
scrubbed_obj <- wookie_scrub(test,preprocess = FALSE)
# Check if the scrubbed object contains scrublet_score and scrublet_call columns
expect_true("scrublet_score" %in% colnames(scrubbed_obj@meta.data))
expect_true("scrublet_call" %in% colnames(scrubbed_obj@meta.data))
})
# Load the testthat package
library(testthat)
library(Seurat)
# Load your custom functions
source("R/WookieTools.R")
test_mat <- Read10X('test_files/sitta1/filtered_feature_bc_matrix/')
test <- CreateSeuratObject(test_mat,min.cells = 3, min.features = 300, project = 'test')
expected_number_of_cells = 3750
# Write test cases using testthat's expect_ functions
test_that("wookieqc filters cells based on specified criteria", {
# Perform quality control
filtered_obj <- wookie_qc(test, nf_min = 1000, nf_max = 9000, nc_max = 80000, pmt = 10, ptr = 50)
# Check if the filtered object has the expected number of cells
expect_equal(ncol(filtered_obj), expected_number_of_cells)
# Add more test cases as needed
})
# Define a test for wookie_scrub
test_that("wookie_scrub correctly processes a Seurat object", {
scrubbed_obj <- wookie_scrub(test,preprocess = TRUE)
# Check if the scrubbed object contains scrublet_score and scrublet_call columns
expect_true("scrublet_score" %in% colnames(scrubbed_obj@meta.data))
expect_true("scrublet_call" %in% colnames(scrubbed_obj@meta.data))
})
# Load the testthat package
library(testthat)
library(Seurat)
# Load your custom functions
source("R/WookieTools.R")
test_mat <- Read10X('test_files/sitta1/filtered_feature_bc_matrix/')
test <- CreateSeuratObject(test_mat,min.cells = 3, min.features = 300, project = 'test')
expected_number_of_cells = 3750
# Write test cases using testthat's expect_ functions
test_that("wookieqc filters cells based on specified criteria", {
# Perform quality control
filtered_obj <- wookie_qc(test, nf_min = 1000, nf_max = 9000, nc_max = 80000, pmt = 10, ptr = 50)
# Check if the filtered object has the expected number of cells
expect_equal(ncol(filtered_obj), expected_number_of_cells)
# Add more test cases as needed
})
# Define a test for wookie_scrub
#test_that("wookie_scrub correctly processes a Seurat object", {
#
#  scrubbed_obj <- wookie_scrub(test,preprocess = TRUE)
#
#  # Check if the scrubbed object contains scrublet_score and scrublet_call columns
#  expect_true("scrublet_score" %in% colnames(scrubbed_obj@meta.data))
#  expect_true("scrublet_call" %in% colnames(scrubbed_obj@meta.data))
#
#})
# Define a test for wookie_multifeatureumap
test_that("wookie_multifeatureumap correctly plots UMAPs for different features", {
# Create a mock Seurat object for testing
test_umap <- readRDS('test_files/Fil_1704.rds')
# Run wookie_multifeatureumap on the mock Seurat object
combined_plot <- wookie_multifeatureumap(test_umap,features = VariableFeatures(test_umap),
min.dist = 0.3,max_features = 1000,step = 500)
# Check if the combined plot object is not NULL
expect_true(!is.null(combined_plot))
})
test_umap <- JoinLayers(test_umap)
# Load the testthat package
library(testthat)
library(Seurat)
# Load your custom functions
source("R/WookieTools.R")
test_mat <- Read10X('test_files/sitta1/filtered_feature_bc_matrix/')
test <- CreateSeuratObject(test_mat,min.cells = 3, min.features = 300, project = 'test')
test_umap <- readRDS('test_files/Fil_1704.rds')
test_umap <- JoinLayers(test_umap)
expected_number_of_cells = 3750
# Write test cases using testthat's expect_ functions
test_that("wookieqc filters cells based on specified criteria", {
# Perform quality control
filtered_obj <- wookie_qc(test, nf_min = 1000, nf_max = 9000, nc_max = 80000, pmt = 10, ptr = 50)
# Check if the filtered object has the expected number of cells
expect_equal(ncol(filtered_obj), expected_number_of_cells)
# Add more test cases as needed
})
# Define a test for wookie_scrub
#test_that("wookie_scrub correctly processes a Seurat object", {
#
#  scrubbed_obj <- wookie_scrub(test,preprocess = TRUE)
#
#  # Check if the scrubbed object contains scrublet_score and scrublet_call columns
#  expect_true("scrublet_score" %in% colnames(scrubbed_obj@meta.data))
#  expect_true("scrublet_call" %in% colnames(scrubbed_obj@meta.data))
#
#})
# Define a test for wookie_multifeatureumap
test_that("wookie_multifeatureumap correctly plots UMAPs for different features", {
# Run wookie_multifeatureumap on the mock Seurat object
combined_plot <- wookie_multifeatureumap(test_umap,features = VariableFeatures(test_umap),
min.dist = 0.3,max_features = 1000,step = 500)
# Check if the combined plot object is not NULL
expect_true(!is.null(combined_plot))
})
# Define a test for wookie_Mindist
test_that("wookie_Mindist correctly plots UMAPs for various min.dist values", {
# Run wookie_Mindist on the mock Seurat object
combined_plot <- wookie_Mindist(test_umap,dims = 1:20)
# Check if the combined plot object is not NULL
expect_true(!is.null(combined_plot))
# Add more test cases as needed
})
test_that('Wookie_get_pc is working', {
pc <- wookie_get_pc(test_umap)
expect_true(!is.null(pc))
})
# Run the tests
test_results <- test_file("R/test_functions.R")
# Print the test results
print(test_results)
# Create plots for each Seurat object
plot_sa1 <- wookie_fc_hist(test, "test",xi = 2500, yi = 0)
# Function to create a plot for a given Seurat object
wookie_fc_hist <- function(seurat_obj, title = 'Feature/Counts Histogram', fi = 0, ci = 0) {
# Extract data
data <- FetchData(seurat_obj, vars = c("nFeature_RNA", "nCount_RNA"))
# Create histograms using ggplot2
p1 <- ggplot(data, aes(x = nFeature_RNA)) +
geom_histogram(bins = 100, fill = "steelblue") +
geom_vline(xintercept = fi, color = "red", linetype = "dashed") +
ggtitle(paste(title, "- Features"))
p2 <- ggplot(data, aes(x = nCount_RNA)) +
geom_histogram(bins = 100, fill = "steelblue") +
geom_vline(xintercept = ci, color = "red", linetype = "dashed") +
ggtitle(paste(title, "- Counts"))
# Return combined plot for each seurat object
return(p1 + p2 + plot_layout(ncol = 2))
}
# Create plots for each Seurat object
plot_sa1 <- wookie_fc_hist(test, "test",xi = 2500, yi = 0)
# Create plots for each Seurat object
plot_sa1 <- wookie_fc_hist(test, "test")
plot_sa1
# Create plots for each Seurat object
wookie_fc_hist(test, "test",fi = 200,ci = 400)
# Create plots for each Seurat object
wookie_fc_hist(test, "test",fi = 2000,ci = 4000)
# Create plots for each Seurat object
wookie_fc_hist(test,title =  "test",fi = 2000,ci = 4000)
# Create plots for each Seurat object
wookie_fc_hist(test,title =  "meh",fi = 2000,ci = 4000)
# Create plots for each Seurat object
wookie_fc_hist(test,fi = 2000,ci = 4000)
# Function to create a plot for a given Seurat object
wookie_fc_hist <- function(seurat_obj, title = 'Histogram', fi = 0, ci = 0) {
# Extract data
data <- FetchData(seurat_obj, vars = c("nFeature_RNA", "nCount_RNA"))
# Create histograms using ggplot2
p1 <- ggplot(data, aes(x = nFeature_RNA)) +
geom_histogram(bins = 100, fill = "steelblue") +
geom_vline(xintercept = fi, color = "red", linetype = "dashed") +
ggtitle(paste(title, "- Features"))
p2 <- ggplot(data, aes(x = nCount_RNA)) +
geom_histogram(bins = 100, fill = "steelblue") +
geom_vline(xintercept = ci, color = "red", linetype = "dashed") +
ggtitle(paste(title, "- Counts"))
# Return combined plot for each seurat object
return(p1 + p2 + plot_layout(ncol = 2))
}
# Create plots for each Seurat object
wookie_fc_hist(test,fi = 2000,ci = 4000)
# Function to create a plot for a given Seurat object
wookie_fc_hist <- function(seurat_obj, title = 'Histogram', fi = 0, ci = 0) {
# Extract data
data <- FetchData(seurat_obj, vars = c("nFeature_RNA", "nCount_RNA"))
# Create histograms using ggplot2
p1 <- ggplot(data, aes(x = nFeature_RNA)) +
geom_histogram(bins = 100, fill = "#06125F") +
geom_vline(xintercept = fi, color = "#FF0909", linetype = "dashed") +
ggtitle(paste(title, "- Features"))
p2 <- ggplot(data, aes(x = nCount_RNA)) +
geom_histogram(bins = 100, fill = "#06125F") +
geom_vline(xintercept = ci, color = "#FF0909", linetype = "dashed") +
ggtitle(paste(title, "- Counts"))
# Return combined plot for each seurat object
return(p1 + p2 + plot_layout(ncol = 2))
}
# Create plots for each Seurat object
wookie_fc_hist(test,fi = 2000,ci = 4000)
devtools::document()
rm(list = c("wookie_featureplot", "wookie_filter_celltype", "wookie_ge_histogram", "wookie_get_pc",
"wookie_matrix_qc", "wookie_matrix_sum", "wookie_Mindist", "wookie_multifeatureumap", "wookie_qc",
"wookie_scrub"))
devtools::document()
rm(list = c("wookie_fc_hist"))
devtools::document()
ls
